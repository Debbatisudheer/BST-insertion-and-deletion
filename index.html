<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Student Records</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    table {
      border-collapse: collapse;
      width: 100%;
    }
    th, td {
      border: 1px solid black;
      padding: 8px;
      text-align: left;
    }
    th {
      background-color: #f2f2f2;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Student Records</h1>
    <div class="menu">
      <button onclick="showInsertForm()">Insert</button>
      <button onclick="showDeleteForm()">Delete</button>
      <button onclick="displayRecords()">Display All</button>
    </div>
    <div id="insertForm" style="display: none;">
      <label for="insertId">Enter Student ID:</label>
<input type="number" id="insertId" min="1" required>

      <label for="insertName">Enter Student Name:</label>
      <input type="text" id="insertName">
      <label for="insertInfo">Additional Info:</label>
      <input type="text" id="insertInfo">
      <button onclick="insertRecord()">Insert</button>
    </div>
    <div id="searchForm" style="display: none;">
      <label for="searchId">Enter Student ID:</label>
      <input type="number" id="searchId">
      <button onclick="searchRecord()">Search</button>
    </div>
    <div id="deleteForm" style="display: none;">
       <label for="deleteId">Enter Student ID to Delete:</label>
  <input type="text" id="deleteId" pattern="^[0-9A-Za-z]{8}$" required title="Please enter a valid 8-character alphanumeric student ID">
  <!-- The pattern attribute ensures that the entered ID consists of exactly 8 alphanumeric characters -->
  <button onclick="deleteRecord()">Delete</button>
    </div>
    <table id="records" style="display: none;">
      <thead>
        <tr>
          <th>ID</th>
          <th>Name</th>
          <th>Additional Info</th>
        </tr>
      </thead>
      <tbody id="recordsTableBody"></tbody>
    </table>
  </div>
    <div class="container">
    <h1>Student Records</h1>
    <pre id="studentTree">
                                      24AB1201 (Shiva)
                                   /                   \
                20AB1202 (Vishnu)                20AC1208 (Hanuman)
               /            \                      /             \
      20AB1203 (Durga) 20AB1204 (Ganesha)  20AB1207 (Lakshmi) 20AC1210 (Brahma)
                 \                                                     \
         20AB1205 (Krishna)                                          20AC1209 (Kali)
                   \
           20AB1206 (Saraswati)
    </pre>
        <a href="https://github.com/Debbatisudheer/BST-insertion-and-deletion/blob/master/bst.py" target="_blank">Code</a></p>
         <p>
      <strong>Visualization Description:</strong>
    </p>
    <ul>
      <li>Each node represents a student record, with the student ID .</li>
      <li>The BST is structured such that for any node:</li>
      <ul>
        <li>All nodes in the left subtree have student IDs less than the node's student ID.</li>
        <li>All nodes in the right subtree have student IDs greater than the node's student ID.</li>
      </ul>
    </ul>
        <div class="container">
    <h1>When to Use Binary Search Trees (BSTs)</h1>
    <h2>When to Consider Using a BST:</h2>
    <ul>
      <li><strong>Fast Search, Insertion, and Deletion:</strong> BSTs offer average-case time complexity of O(log n) for search, insertion, and deletion operations, making them suitable for scenarios where fast access to data is required.</li>
      <li><strong>Dynamic Data:</strong> BSTs are efficient for managing dynamic data sets where elements are frequently added, removed, or modified while maintaining sorted order.</li>
      <li><strong>Sorted Order:</strong> BSTs inherently maintain elements in sorted order, which can be beneficial for applications where sorted data access is required.</li>
      <li><strong>Tree Traversal:</strong> BSTs support efficient traversal operations like in-order, pre-order, and post-order traversal, which can be useful for various algorithms and applications.</li>
    </ul>
    <h2>When BSTs May Not Be the Best Choice:</h2>
    <ul>
      <li><strong>Balanced Tree Maintenance:</strong> In worst-case scenarios where the BST becomes unbalanced (e.g., all elements are inserted in sorted order), the time complexity of operations degrades to O(n), making BSTs inefficient. Self-balancing trees like AVL trees or Red-Black trees are preferred in such cases.</li>
      <li><strong>Memory Overhead:</strong> BSTs require additional memory overhead for storing pointers, which may not be suitable for memory-constrained environments or scenarios where memory efficiency is critical.</li>
      <li><strong>No Duplicate Keys:</strong> Traditional BSTs do not allow duplicate keys. If duplicate keys need to be stored, you'll need to modify the BST implementation accordingly or use alternative data structures like MultiMap.</li>
      <li><strong>Not Suitable for Range Queries:</strong> BSTs are efficient for searching for specific keys but not ideal for range queries where you need to find all keys within a given range efficiently.</li>
    </ul>
    <p>In summary, while BSTs offer efficient search, insertion, and deletion operations in average cases, they may not be suitable for all scenarios, especially when dealing with worst-case scenarios, memory constraints, or specific query requirements. It's essential to analyze the characteristics of your data and the requirements of your application before choosing BSTs or considering alternative data structures.</p>
  </div>
        <div class="container">
    <h1>Key Points for BST Insertion and Deletion</h1>
    <ul>
      <li>
        <strong>Insertion:</strong>
        <ul>
          <li>When inserting a new node into the BST, the node must be placed in such a way that it maintains the properties of a BST.</li>
          <li>The new node should be inserted as a leaf node, ensuring that it is placed at the correct position based on its key value (ID in your case).</li>
          <li>Traverse the tree from the root node downwards, comparing the key of the new node with each node encountered until a suitable leaf node position is found.</li>
        </ul>
      </li>
      <li>
        <strong>Deletion:</strong>
        <ul>
          <li>Deletion in a BST can be more complex because it needs to maintain the BST properties after removing a node.</li>
          <li>If the node to be deleted has no children (leaf node), simply remove the node from the tree.</li>
          <li>If the node has one child, replace the node with its child.</li>
          <li>If the node has two children, find the inorder successor (the smallest node in the right subtree) or the inorder predecessor (the largest node in the left subtree), replace the node with it, and then recursively delete the inorder successor/predecessor from its original position.</li>
          <li>Ensure that the BST properties are preserved after deletion.</li>
        </ul>
      </li>
      <li>
        <strong>BST Properties:</strong>
        <ul>
          <li>The key property of a BST is that for each node, all nodes in its left subtree have keys less than its own key, and all nodes in its right subtree have keys greater than its own key.</li>
          <li>When performing insertion and deletion, it's essential to maintain these properties to ensure that the tree remains a valid BST.</li>
        </ul>
      </li>
    </ul>
  </div>
         <div class="container">
    <h1>Time and Space Complexity of BST Operations</h1>
    <p>The time complexity of Binary Search Tree (BST) insertion and deletion operations depends on the height of the tree. In the best-case scenario, where the tree is balanced, the height of the tree is O(log n), where n is the number of nodes in the tree. However, in the worst-case scenario, where the tree becomes skewed (e.g., all nodes are inserted in increasing or decreasing order), the height of the tree can be O(n), making the time complexity of insertion and deletion operations O(n).</p>
    <ul>
      <li>
        <strong>Insertion:</strong>
        <ul>
          <li>Best Case: O(log n)</li>
          <li>Worst Case: O(n)</li>
        </ul>
      </li>
      <li>
        <strong>Deletion:</strong>
        <ul>
          <li>Best Case: O(log n)</li>
          <li>Worst Case: O(n)</li>
        </ul>
      </li>
    </ul>
    <p>The space complexity of BST insertion and deletion operations is O(1) for each operation, as they only involve modifying existing nodes and pointers without requiring additional memory allocation. However, if the BST is implemented using a dynamic data structure like a linked list, the space complexity would be O(n) to store n nodes.</p>
  </div>
  </div>
  <div class="container">
    <h1>Binary Search Tree Operations</h1>
    <ul>
      <li>Insertion Operation:</li>
      <ul>
        <li>Start from the root: To insert a new element into a BST, start at the root node.</li>
        <li>Compare with the current node: If the value to be inserted is less than the value of the current node, move to the left subtree. If it's greater, move to the right subtree.</li>
        <li>Find the appropriate position: Repeat step 2 until you reach a leaf node (a node with no children) where you can insert the new value.</li>
        <li>Insert the new node: Create a new node with the value to be inserted and attach it as a child to the leaf node found in step 3.</li>
        <li>Maintain the BST property: After inserting the new node, make sure the BST property is maintained, i.e., all values in the left subtree are less than the value of the current node, and all values in the right subtree are greater.</li>
      </ul>
      <li>Deletion Operation:</li>
      <ul>
        <li>Deletion in a BST is a bit more complicated because we need to maintain the BST property after deletion. There are three main cases to consider:</li>
        <ul>
          <li>Node with no children (leaf node): Simply remove the node from the tree.</li>
          <li>Node with one child: Replace the node to be deleted with its child. If it's a left child, attach the left child of the node to be deleted to its parent. If it's a right child, attach the right child of the node to be deleted to its parent.</li>
          <li>Node with two children: This is the trickiest case. We need to find either the maximum value in the left subtree or the minimum value in the right subtree to replace the node to be deleted. This ensures that the BST property is maintained.</li>
          <ul>
            <li>Find the inorder predecessor (maximum value in the left subtree) or inorder successor (minimum value in the right subtree) of the node to be deleted.</li>
            <li>Replace the value of the node to be deleted with the value of its inorder predecessor or inorder successor.</li>
            <li>Delete the inorder predecessor or inorder successor node from the subtree where it was found.</li>
          </ul>
        </ul>
        <li>After deletion, make sure to check if the BST property is still maintained. If not, rebalance the tree if necessary to ensure efficient search operations.</li>
      </ul>
    </ul>
  </div>
  <div class="container">
    <h1>Binary Search Trees in Databases</h1>
    <p>
      Many databases, especially those that implement indexing mechanisms, use Binary Search Trees (BSTs) for efficient storage and retrieval of data. For example, in database management systems like MySQL and PostgreSQL, BSTs are used in index structures like B-trees and AVL trees.
    </p>
       <p>
      Database management systems often use Binary Search Trees (BSTs) for indexing and searching data efficiently. For example, BSTs are used in SQL databases for creating indexes on tables to speed up queries.
    </p>
    <p>
      Additionally, BST-based structures such as B-trees and AVL trees are widely employed in database systems to organize and manage data effectively, providing fast access and retrieval operations even for large datasets.
    </p>
       <h1>Binary Search Trees in Database Indexing</h1>
        <p>
      We'll create a BST index on the Student ID column to facilitate fast retrieval of student records based on their ID.
    </p>
    <ul>
      <li><strong>BST Insertion for Indexing:</strong></li>

      <ul>
        <li><strong>Start from the Root:</strong> To insert a new entry into the BST index, the process begins by starting at the root of the tree.</li>
        <li><strong>Compare with Current Node:</strong> The key value of the new entry (often a unique identifier or a value from the indexed column in the database table) is compared with the key value of the current node.</li>
        <li><strong>Move to the Left or Right:</strong> Based on the comparison result, if the new key value is less than the key value of the current node, the insertion process moves to the left subtree. If the new key value is greater, the process moves to the right subtree.</li>
        <li><strong>Find the Appropriate Position:</strong> The process continues recursively until a leaf node (a node with no children) is reached or a duplicate key value is found. If a leaf node is reached, the new entry is inserted as a child of this leaf node.</li>
        <li><strong>Maintain BST Property:</strong> After insertion, it's essential to ensure that the binary search tree property is maintained: all keys in the left subtree are less than the key of the current node, and all keys in the right subtree are greater.</li>
      </ul>
      <li><strong>BST Deletion for Indexing:</strong></li>
      <ul>
        <li><strong>Search for the Node to Delete:</strong> To delete an entry from the BST index, the process begins with a search for the node containing the key value to be deleted.</li>
        <li><strong>Handle Different Cases:</strong> Once the node to be deleted is found, different cases are considered:
          <ul>
            <li><strong>Node is a Leaf Node:</strong> If the node has no children, it can be simply removed from the tree.</li>
            <li><strong>Node has One Child:</strong> If the node has only one child, the child node replaces the deleted node.</li>
            <li><strong>Node has Two Children:</strong> If the node has two children, a successor node (either the minimum value from the right subtree or the maximum value from the left subtree) replaces the deleted node.</li>
          </ul>
        </li>
        <li><strong>Maintain BST Property:</strong> After deletion, the BST property must be maintained by reorganizing the tree as necessary.</li>
      </ul>
    </ul>
  </div>
   <div class="container">
    <h1>Data Structures for Large Datasets</h1>
    <p>
      If you have a large amount of student data, storing it in a Binary Search Tree (BST) may not be the most efficient solution. While BSTs offer efficient search operations, their performance can degrade if the tree becomes unbalanced, leading to poor insertion and deletion times.
    </p>
    <p>
      For a large dataset of student records, alternative data structures may be more suitable, especially if you need to optimize for efficient insertion, deletion, and retrieval operations. Here are a few considerations:
    </p>
    <ul>
      <li><strong>Balanced Binary Search Trees (AVL Trees, Red-Black Trees):</strong> These are variants of BSTs that automatically maintain balance during insertion and deletion operations, ensuring that the height of the tree remains logarithmic in the number of nodes. This helps maintain efficient search, insertion, and deletion times even for large datasets.</li>
      <li><strong>Hash Tables:</strong> Hash tables offer constant-time average-case performance for insertion, deletion, and retrieval operations. They are particularly useful when you need fast access to data and don't require ordering based on a key.</li>
      <li><strong>B-Trees:</strong> B-Trees are widely used in database systems and file systems for storing large datasets efficiently. They maintain balance by allowing each node to have multiple children, making them suitable for handling large amounts of data with good performance characteristics.</li>
      <li><strong>Database Management Systems (DBMS):</strong> For very large datasets, especially in a multi-user environment, a full-fledged database management system (DBMS) like MySQL, PostgreSQL, or MongoDB may be the most appropriate solution. These systems offer indexing capabilities, query optimization, and scalability features to efficiently handle large volumes of data.</li>
    </ul>
    <p>
      When dealing with a large dataset of student records, it's essential to consider factors such as the expected size of the dataset, the frequency of data modifications, the required performance characteristics, and the capabilities of the underlying system or platform. Depending on these factors, you can choose the most appropriate data structure or system to store and manage your data effectively.
    </p>
        <div class="container">
    <h1>BST Index for Student Records</h1>
    <div class="info-container">
      <h2>Construction of BST Index:</h2>
      <ul>
        <li>We generate a dataset of student records, each containing a unique student ID and a corresponding name.</li>
        <li>We construct a BST index based on the student IDs, where each student ID serves as the key in the BST, and the associated name is stored as the value.</li>
      </ul>
  </div>

    <div class="info-container">
      <h2>Usage of BST Index:</h2>
      <ul>
        <li>Once the BST index is constructed, it can efficiently support operations such as searching for student records based on their IDs.</li>
        <li>The BST index allows for fast retrieval of student records by student ID. When a search operation is performed, the BST is traversed starting from the root node, and comparisons are made to navigate to the appropriate subtree based on the search key (student ID).</li>
      </ul>
    </div>
    <div class="summary-container">
      <h2>Summary:</h2>
      <p>In summary, the BST index is a data structure that organizes student records based on their student IDs, allowing for efficient retrieval of records using the student IDs as search keys.</p>
         <div class="container">
    <h1>BST Index Operations for Student Records</h1>
    <ul>
      <li>
        <strong>Search by Student ID:</strong>
        <ul>
          <li>Given a student ID, you can quickly find the corresponding student record by traversing the BST index. This operation has a time complexity of O(log n) on average, where n is the number of student records in the BST.</li>
        </ul>
      </li>
      <li>
        <strong>Insertion of New Student Records:</strong>
        <ul>
          <li>You can insert new student records into the BST index by adding new nodes with unique student IDs. The BST property ensures that the insertion operation maintains the order of the tree, allowing for efficient insertion with a time complexity of O(log n) on average.</li>
        </ul>
      </li>
      <li>
        <strong>Deletion of Student Records:</strong>
        <ul>
          <li>You can delete existing student records from the BST index based on their student IDs. The deletion operation preserves the BST property while removing the specified nodes, and it typically has a time complexity of O(log n) on average.</li>
        </ul>
      </li>
      <li>
        <strong>Traversal of Student Records:</strong>
        <ul>
          <li>You can traverse the BST index to visit all student records in a specific order, such as in-order, pre-order, or post-order traversal. Traversal operations allow you to iterate through the student records efficiently.</li>
        </ul>
      </li>
      <li>
        <strong>Range Queries:</strong>
        <ul>
          <li>You can perform range queries to retrieve student records within a specific range of student IDs. By leveraging the BST property, range queries can be efficiently executed with a time complexity proportional to the size of the output range.</li>
        </ul>
      </li>
      <li>
        <strong>Finding Minimum and Maximum Student IDs:</strong>
        <ul>
          <li>You can find the student record with the minimum or maximum student ID by traversing the BST to the leftmost or rightmost node, respectively. These operations have a time complexity of O(log n) on average.</li>
        </ul>
      </li>
    </ul>
    <p>Overall, the BST index provides efficient support for searching, insertion, deletion, traversal, and range query operations on student records based on their student IDs. These operations leverage the inherent properties of the BST data structure to achieve logarithmic time complexity, making them suitable for handling large datasets efficiently.</p>
  </div>
  <div class="container">
    <h1>Efficient Data Structures for College Databases</h1>
    <p>In real-world scenarios like college databases, the order of data insertion may vary based on factors such as enrollment dates, course registration, or administrative procedures. It's unlikely that college databases would intentionally use a skewed binary search tree (BST) structure because skewed trees can lead to inefficient operations, especially for search, insertion, and deletion.</p>
    <p>Instead, colleges would likely prefer balanced BST structures or other efficient data structures that maintain balance automatically, such as AVL trees, Red-Black trees, or B-trees. These balanced tree structures ensure that operations like searching, inserting, and deleting records can be performed efficiently, regardless of the order of data insertion.</p>
    <p>Efficient data structures are crucial for managing large datasets efficiently and ensuring that database operations can be performed in a timely manner. Therefore, in practice, colleges and other organizations would prioritize using balanced tree structures or other efficient data structures over skewed trees for their databases.</p>
  </div>
         <footer>
    <p>&copy; 2024 @sudheer debbati. All rights reserved.</p>
  </footer>
  <script src="script.js"></script>
</body>
</html>




